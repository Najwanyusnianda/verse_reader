// lib/src/features/notes/data/notes_dao.dart

import 'package:drift/drift.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:verse_reader/src/core/database/app_database.dart';
import 'package:verse_reader/src/core/database/tables.dart';
import 'package:verse_reader/src/core/database/database_provider.dart';
// This file is generated by Drift to provide the _$NotesDaoMixin
part 'notes_dao.g.dart';

/// Data Access Object for managing notes in the database.
/// Uses Drift's code generation to provide type-safe database operations.
@DriftAccessor(tables: [Notes])
class NotesDao extends DatabaseAccessor<AppDatabase> with _$NotesDaoMixin {
  /// Creates a new NotesDao instance.
  /// Requires an instance of [AppDatabase] to interact with the database.
  NotesDao(super.db);

  /// Watches all notes associated with a specific book ID.
  /// The results are ordered by the location in the book.
  /// 
  /// Parameters:
  /// * [bookId] - The ID of the book to get notes for
  /// 
  /// Returns a [Stream] that emits a list of [Note] objects whenever the
  /// notes for the given book change.
  Stream<List<Note>> watchNotesForBook(int bookId) {
    return (select(notes)
          ..where((n) => n.bookId.equals(bookId))
          ..orderBy([(n) => OrderingTerm(expression: n.locationIdentifier)]))
        .watch();
  }

  /// Creates a new note in the database.
  /// 
  /// Parameters:
  /// * [entry] - A [NotesCompanion] containing the note data to insert
  /// 
  /// Returns a [Future] that completes with the ID of the newly created note.
  Future<int> createNote(NotesCompanion entry) {
    return into(notes).insert(entry);
  }

  /// Updates an existing note in the database.
  /// 
  /// Parameters:
  /// * [entry] - A [NotesCompanion] containing the updated note data
  /// 
  /// Returns a [Future] that completes with `true` if the update was successful.
  Future<bool> updateNote(NotesCompanion entry) {
    return update(notes).replace(entry);
  }

  /// Deletes a specific note from the database.
  /// 
  /// Parameters:
  /// * [id] - The ID of the note to delete
  /// 
  /// Returns a [Future] that completes with the number of rows deleted (should be 1).
  Future<int> deleteNote(int id) {
    return (delete(notes)..where((n) => n.id.equals(id))).go();
  }
}

@riverpod
NotesDao notesDao(Ref ref) {
  final db = ref.watch(appDatabaseProvider);
  return NotesDao(db);
}