// lib/src/features/library/presentation/providers/library_providers.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:verse_reader/src/features/library/data/book_repository_impl.dart';
import 'package:verse_reader/src/features/library/data/books_dao.dart';
import 'package:verse_reader/src/features/library/domain/book_repository.dart';
import 'package:verse_reader/src/core/database/app_database.dart';

// This file is generated by Riverpod to provide the necessary provider code
part 'library_providers.g.dart';

/// The provider for the [BookRepository].
///
/// This provider is responsible for creating an instance of our concrete
/// repository implementation, [DriftBookRepository]. It automatically
/// handles fetching the [BooksDao] dependency from its own provider.
///
/// Components in the app will depend on this provider to get a
/// [BookRepository] instance, without needing to know which concrete
/// implementation is being used.
///
/// Example usage:
/// ```dart
/// final bookRepository = ref.watch(bookRepositoryProvider);
/// final books = await bookRepository.watchAllBooks();
/// ```
@riverpod
BookRepository bookRepository(Ref ref) {
  // Get the BooksDao from its provider
  final booksDao = ref.watch(booksDaoProvider);
  
  // Create and return the concrete repository implementation
  return DriftBookRepository(booksDao: booksDao);
}

// ---- ADD THE NEW PROVIDER BELOW ----

/// A provider that fetches the details of a single book.
/// The `.family` modifier allows us to pass an argument, the `bookId`.
/// Riverpod will automatically cache the result, so if we ask for the same
/// book ID again, it will return the cached data instantly.
@riverpod
Future<Book?> bookDetails(Ref ref, int bookId) {
  final repository = ref.watch(bookRepositoryProvider);
  return repository.getBookById(bookId);
}